## 哈希表（hash table）

哈希表也叫散列表（hash有剁碎的意思）

添加、搜索、删除的流程都是类似的

1. 利用哈希函数生成key对应的index【O(1)】
2. 根据index操作定位数组元素【O(1)】

哈希表是【空间换时间】的典型应用

哈希函数也叫做散列函数

哈希表内部的数组元素，很多地方也叫 BucketBucket（桶），整个数组叫 Buckets 或者 Bucket Array

## hash冲突（Hash Collision）

hash冲突也叫哈希碰撞

- 2个不同的key，经过hash函数计算出相同的结果

解决hash冲突的常见方法

1. 开放定址法（Open Addressing）：按照一定规则向其它地址探测，知道遇到空桶
2. 再hash法（Re-Hashing）：设计多个hash函数
3. 链地址法（Separate Chaining）：比如通过链表将同一index的元素串起来

在JDK1.8中，默认使用单链表将元素串起来。

在添加元素时，可能会由单链表转为红黑树存储元素。比如当hash表容量≥64且单链表的节点数量>8时。

当红黑树节点数量少到一定程度时，又会转为单链表

## 哈希函数

hash表中哈希函数的实现步骤大概如下

1. 先生成key的哈希值（必须是整数）
2. 再让key的哈希值跟数组的大小进行相关运算，生成一个索引值

```go
func hash(key any) int {
    return hash_code(key) % len(table)
}
```

为了提高效率，可以使用&位运算取代%运算【前提：将数组的长度设计为2的幂（2^n）】，这样，进行&运算后返回的整数，一定小于数组长度

```go
func hash(key any) int {
    return hash_code(key) & (len(table) - 1)
}
```

良好的哈希函数，可以让哈希值更加均匀分布，减少哈希冲突次数，提高哈希表性能

## 生成哈希值

key的常见类型有：整数、浮点数、字符串、自定义对象。不同种类的key，哈希值的生成方式不一样，但是目标是一致的。

- 尽量让每个 key 的哈希值是唯一的。
- 尽量让key的所有信息参与运算

在Java 中， HashMap 的 key 必须实现 hashCode 、equals 方法，也允许 key 为 null

### 整数哈希值

整数的哈希值就是本身

```go
func hashCode(value int) {
    return value
}
```



### 浮点数哈希值

将存储的二进制格式转为整数值

```go
func hashCode(value float32) {
    return value
}
```



### 字符串哈希值

### 自定义对象哈希值

