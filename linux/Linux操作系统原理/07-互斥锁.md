## 临界区问题

Critical-Section Problem

- 每一个并发的进程都有一段称为临界区的代码。在这段代码中进程可能修改公共数据。
- 当一个进程正在临界区中执行的时候，没有其它进程可以在这个临界区中执行。也就是同时只能有一个进程在临界区中执行
- 临界区问题就是设计一个进程可以互相协作的协议

进程进出临界区协议

```go
for {
    entry section
        critial section
    exit section
}
```

进入临界区前在entry section要请求许可，离开临界区后在exit section要归还许可

### 临界区管理准则

有空让进

择一而入

无空等待

有限等待

让权等待

- Mutual exclusion（Mutex）互斥：只能有一个进临界区
- Progress 前进：如果临界区中没有进程，则一定有进程可以进入临界区，不能让进程一直在外面等
- Bounded waiting 有限等待：

## 互斥锁

一个进程进入一个临界区的时候必须获取锁；当离开临界区的时候释放锁 

### 锁的基本操作

```
lock()

if (xxx) {
    do something
}

unlock()
```

- 上锁
  - 等待锁至打开状态
  - 获得锁并锁上
- 解锁
- 原子操作

### 原子操作

原子操作意味着指令在被执行过程中不能被打断。下面两条硬件指令都是原子操作，它们可以被用来实现对临界区的管理（也就是“锁”）。

```
test_and_set()
compare_and_swap()
```

 